# 学习笔记

### 总感

+ 学会 Google, 自主学习
+ 对于不擅长的事物，需要科学的，有目标的刻意训练
+ 学习知识时，尝试做成脑图，更有助于大脑的记忆，已经系统化的理解
+ 题并不是只做一遍就可以吸收的，需要多做几遍，确定自己确实会写，思考所用的方法，是否有改进的空间（好题需要多做）
+ 正视自己不足的地方，敢于借助外力来提高自己
+ 在做题时，保持自己的兴趣最重要，不要丧失信心，也要虚心请教他人（对比他人的优秀代码）
+ 优化代码时，升维，空间换时间。
+ 一些编程习惯，工欲善其事，必先利其器
+ 自顶向下编程法
  

### 练题
+ 确认自己已经清楚的理解题目的意思
+ 思考所有可能的解法，并快速对比他们的时间和空间复杂度，找一个想到的最优的解法来求解
+ 碰到的题完全没有思路时：  
    1. 解答先思考最为简单的情况，再慢慢复杂化，是否能找到最近重复子问题，
    2. 是否可以通过暴力
    3. 直接看解答  
+ 不要死磕，时间不要超过十分钟


### 五毒神掌
+ 第一遍，不要死磕， 先思考五至十分钟，想不出来直接去看他人的优秀解答。（中英文都要去看）
+ 第二遍，闭卷解答
+ 第三遍，过一天后再去写，是否有优化的地方
+ 第四遍，一星期后再来写，是否有优化的地方
+ 第五遍，面试前一周回顾做过的题


### 笔记
##### 数组：
    1. 访问很快，为O(1)
    2. 但添加和删除都需要挪动其他元素的位置，时间复杂度为 O(n).
    3. 不适用添加和删除很频繁的工程中

##### 链表
    1. 添加和删除只是改变指针，所以复杂度只为 O(1)
    2. 但访问将会变为 O(n)

##### 跳表
    ** 必须是有序的 **
    添加索引(升维)，加快了访问的速度
    时间复杂度 O(logN), 空间复杂度 O(n),但在添加和删除时都需要更新一遍索引，维护成本较高


##### 栈和队列
    栈： 前进后出
    队列: 前进先出
    + 添加和删除均为 O(1)，访问为 O(n)

    ** 优化 ** 
    双端队列(栈和队列的结合体): 头和尾都可以进行添加和删除操作
    优先队列：根据优先级取出，时间复杂度为 O(logN)，底层实现较为多样复杂
    


##### 任何高级的算法，本质上都是 if else/ for while loop/ recursion
##### 算法与空间结构相辅相成，在特定的结构里，就会有好的算法进行优化
##### 没有绝对厉害的数据结构，只有最为适合的数据结构